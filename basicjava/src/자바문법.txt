+++ 시험은 교재 확인문제 같은 곳에서 출제

0. 이클립스 단축키
 - ctrl + / : 주석
 - ctrl + shift + o : 자동 import
 - ctrl + shift + f : 코드 정리
 - ctrl + d : 라인삭제

1. 변수
   데이터타입 변수명 = 변수에 저장될 값
   
   ex) 숫자를 저장할 수 있는 공간
       num = 100
        |_____|
          num 변수에 100이 할당 (대입)
   
2. 데이터타입
   기본형 / 참조형
   
   1) 기본형
      - 값이 저장된다
      - 변수에 할당되는 값을 리터럴이라고 함
      - 정수형 변수에 저장되는 리터럴은 기본 데이터 타입이 int형
      - 실수형 변수에 저장되는 리터럴은 기본 데이터 타입이 double형
      - int형 변수의 연산은 결과도 int형
      - long타입은 리터럴로 표현할 수 있는 범위 밖의 값을 저장해야하므로 접미사를 추가해서 
        int 타입이 아니라 long 리터럴이라는 것을 컴파일러에게 알려준다. (l, L)
      - float타입도 long처럼 접미사를 추가해야한다 (f, F)
      - char타입의 변수에 할당되는 리터럴은 ' '로 표현한다
      
      ① 정수형
       - byte(1)
       - short(2)
       - int(4)
       - long(8)
       
      ② 실수형
       - float(4)
       - double(8)
       
      ③ 논리형
       - boolean(true/false)
       
      ④	문자형
       - char(1)
       
   2) 참조형
      - API 클래스나 직접 작성한 클래스를 메모리에 할당한 후 사용하기 위해서 선언한 변수 
      - 주소값을 가지고 있다.
      - new 연산자를 이용해서 클래스를 메모리에 저장(객체 생성, 인스턴스화)
      - heap에 할당된 클래스를 객체, 인스턴스라 한다.
      - 생성된 객체의 주소를 갖고있는 변수를 이용해서 객체의 기능을 사용
                        ----------------
                           객체 참조
      - . 연산자를 통해 접근
      
      할당될클래스 변수 = new heap할당될클래스명()
      ---------           --------------
      데이터 타입             사용하고 싶은 클래스

 3. 데이터 형 변환
   1) 기본형
     ① 자동 형 변환
       - 작은 데이터를 큰 데이터타입의 변수에 저장할 수 있다.
       
       byte > short > int > long > float > double
              char > int
       
       ???: long은 8바이트인데, float은 4바이트인데 형 변환이 가능한가?
        => 지수표현이 가능한 실수형 타입이 표현범위가 더 넓기 때문에 가능
        => 테스트 : PrimitiveTypeCastingTest.java       
       
     ② 명시적 형 변환(강제 형 변환)
       - 강제로 데이터의 타입을 변환
       int i = 10;
       byte data = i;
       - 사이즈가 큰 변수를 작은 변수에 할당할 수 없다
       - 이런 경우에 강제로 형을 변환해야 한다.
       
       타입 변수 = (변환하려고하는데이터타입) 변수;
   
   2) 참조형
   
 4. 제어구문
    - 문장의 흐름에 따라서 순차형, 선택형, 반복형
    1) 조건제어문
       ① if
         [if]
           if(조건) { ---> 조건은 true/false로 리턴되는 연산식이나 메소드 호출문
              조건이 만족하는 경우 실행될 문장
           }
         [if ~ else]
           if(조건) {
           	  조건이 만족하는 경우 실행될 문장
           } else {
              조건이 만족하지 않을 경우 실행될 문장
           }
         [if ~ else if ~ else if ... else]
           if(조건1) {
              조건1이 만족하는 경우 실행될 문장
           } else if(조건2) {
              조건2가 만족하는 경우 실행될 문장
           } else {
              모든 조건을 만족하지 않는 경우 실행할 문장
           }
           
       ② switch
         - if else if문을 대신할 수 있도록 만들어진 제어구문
         - 다중분기
         - switch() 안에서 발생한 값들이 case 문과 일치하면 실행된다.
         - case 문에는 >, >=, <, <=와 같은 비교연산자를 사용할 수 없다.
         - 정확하게 일치하는 값만 비교
         - 모든 case 문을 실행하므로 각 case 문의 종단에 break 문을 선언해서
           평가 후 switch 블럭을 빠져나가도록 처리한다
         - if문의 else 와 같은 역할을 하는 default 문을 추가
         - switch 내부에 조건을 평가하기 위한 변수는 int로 자동 캐스팅되는 타입 (short, int, String, char)
         
         [문법]
         switch(평가할 수 있는 변수 or 연산식 or 메소드호출문){
               --------------------------------------
                     특정 값을 리턴할 수 있도록 작성
             case 값1:
             case 값2:
               ....
         }
       
    2) 반복제어문
       ① for
       ② while
       ③ do ~ while
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   

 [객체의 형변환]
 
1. 상위타입의 변수로 하위객체를 참조할 수 있다. -> 자동캐스팅
   상위타입 변수 = new 하위객체()
   => 변수의 실제 타입에 대한 멤버를 하위 객체가 모두 가지고 있으므로 가능

2. 오버라이딩 된 메소드가 있는 경우 무조건 오버라이딩 된 메소그가 호출된다.

3. 참조변수가 상위타입이면, 상위 타입의 멤버만 사용할 수 있다.
4. 참조변수가 상위타입이라고 하더라도 생성된 객체가 하위 객체라면 명시적으로 형변환하여 사용할 수 있다.
   ((캐스팅할클래스타입)참조변수).메소드()  
   